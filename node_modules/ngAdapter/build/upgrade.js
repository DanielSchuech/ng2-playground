"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require('angular2/core');
var scopeevents_1 = require('./scopeevents');
var scope_1 = require('./scope');
var Upgrade = (function () {
    function Upgrade(upgradeAdapter, module, addedProvider, upgradedProviders) {
        this.upgradeAdapter = upgradeAdapter;
        this.module = module;
        this.addedProvider = addedProvider;
        this.upgradedProviders = upgradedProviders;
    }
    Upgrade.prototype.upgradeNg1Directive = function (directive) {
        var directiveFnOrArray = this.searchDirective(directive);
        var fn = this.evaluateDirectiveAndDeps(directiveFnOrArray);
        return this.createDirective(directive, fn.function, fn.dependencies);
        //return () => {};
    };
    /**
     * searches in angular.module for the directive and returns it
     */
    Upgrade.prototype.searchDirective = function (directive) {
        /**
         * invokeQuee contains all actions on angular.module
         * including controller, directive & service declarations
         */
        var queue = this.module._invokeQueue;
        if (queue.length === 0) {
            showError();
        }
        var foundFunction;
        queue.forEach(function (action) {
            if (action.length >= 3) {
                /**
                 * action[0] i.e. $controllerProvider | $provide
                 * action[1] i.e. register | factory | directive
                 * action[2][0] name
                 * action[2][1] function
                 */
                if (action[1] === 'directive' && action[2][0] === directive) {
                    foundFunction = action[2][1];
                }
            }
        });
        if (!foundFunction) {
            showError();
        }
        return foundFunction;
        function showError() {
            throw new Error('Cannot find directive: ' + directive);
        }
    };
    /**
     * searches for the directive function and the required dependencies
     * return {
     *  function: Function -> directive Function
     *  dependencies: string[] -> required Dependencies
     * }
     */
    Upgrade.prototype.evaluateDirectiveAndDeps = function (directive) {
        /**
         * directive is an Fn or Array:
         *    * array for Inline Array Annotation
         *      i.e. ['$scope', 'greeter', function($scope, greeter) {}]
         *    * function -> dependency names are located in directive.$inject
         */
        /** Inline Array Notation */
        if (Array.isArray(directive)) {
            var fn = directive.splice(directive.length - 1, 1)[0];
            var dependencies = directive;
            return {
                function: fn,
                dependencies: dependencies
            };
        }
        else {
            return {
                function: directive,
                dependencies: directive.$inject
            };
        }
    };
    /**
     * create a directive
     */
    Upgrade.prototype.createDirective = function (selector, fn, deps) {
        //evaluate bindings
        var bindings = Object.keys(fn().scope || {});
        //evaluate events
        var events = [];
        bindings.forEach(function (binding) {
            events.push(binding + 'Changed: ' + binding + 'Change');
        });
        //evaluate properties
        var properties = {
            selector: '[' + selector + ']',
            properties: bindings,
            events: events
        };
        var addedProviders = this.addedProvider;
        var upgradedProviders = this.upgradedProviders;
        var ngAdapterDirective = (function () {
            function ngAdapterDirective(injector, element, scopeEvents) {
                var _this = this;
                this.injector = injector;
                this.element = element;
                this.scopeEvents = scopeEvents;
                this.oldBindingValues = {};
                this._equals = {}; //selfdefined equals functions (i.e. in scope watch)
                this._watch = {}; //listeners for scope watch
                bindings.forEach(function (binding) {
                    //setup output events for two way binding
                    _this[binding + 'Changed'] = new core_1.EventEmitter();
                    _this.oldBindingValues[binding] = _this[binding];
                });
            }
            ngAdapterDirective.prototype.ngOnInit = function () {
                var scope = this;
                //setting up scope 
                scope_1.Scope.setUp(scope, this.scopeEvents);
                var dependencies = determineDependencies(deps, this.injector, addedProviders, upgradedProviders);
                var directive = fn.apply(void 0, dependencies);
                directive.link(scope, [this.element.nativeElement], {});
            };
            ngAdapterDirective.prototype.ngDoCheck = function () {
                var _this = this;
                bindings.forEach(function (binding) {
                    var scope = _this;
                    var equals = scope._equals[binding] || function (a, b) { return a === b; };
                    if (!equals(_this.oldBindingValues[binding], scope[binding])) {
                        //binding value changed
                        //emit output event
                        scope[binding + 'Changed'].next(scope[binding]);
                        //execute scope $watch
                        scope_1.Scope.executeScopeWatchListener(binding, scope, _this.oldBindingValues[binding], scope[binding]);
                        //reset old binding value
                        _this.oldBindingValues[binding] = scope[binding];
                    }
                });
            };
            ngAdapterDirective = __decorate([
                core_1.Directive(properties), 
                __metadata('design:paramtypes', [core_1.Injector, core_1.ElementRef, scopeevents_1.ScopeEvents])
            ], ngAdapterDirective);
            return ngAdapterDirective;
        }());
        /**
         * Angular2 uses the name to find the directiv function
         * change read-only name property to find the different upgraded directives
         */
        Object.defineProperty(ngAdapterDirective, "name", {
            value: 'ngAdapterDirective_' + selector
        });
        return ngAdapterDirective;
    };
    return Upgrade;
}());
exports.Upgrade = Upgrade;
/**
 * inputs array of dependencies as string + more needed information
 * return array with dependencies objects
 */
function determineDependencies(deps, injector, addedProviders, upgradedProviders) {
    var dependencies = [];
    deps && deps.forEach(function (dep) {
        //check if dependency is a ng2Provider
        var depKeyNg2 = addedProviders[dep];
        //check if dependency is a ng1Provider
        var depKeyNg1;
        if (upgradedProviders.indexOf(dep) > -1) {
            depKeyNg1 = dep;
        }
        //warn if provider in ng1 & 2 available
        if (depKeyNg1 && depKeyNg2) {
            depKeyNg2 = undefined;
            console.warn('Provider ' + dep + ' is available in native ng1 and native ng2!' +
                'Using ng1 Provider! Check for naming conflicts!');
        }
        //throw Error if provider is not available
        if (!depKeyNg1 && !depKeyNg2) {
            throw new Error('Provider ' + dep + ' is not available!');
        }
        var depObj = injector.get(depKeyNg1 || depKeyNg2);
        dependencies.push(depObj);
    });
    return dependencies;
}
//# sourceMappingURL=upgrade.js.map